from typing import Iterator

from agentfuzz.analyzer.dynamic.coverage import Coverage


class Fuzzer:
    """Executable fuzzer object."""

    def minimize(self, corpus_dir: str, outdir: str):
        """Minimize the corpus.
        Args:
            corpus_dir: a path to the directory containing fuzzing inputs (corpus).
            outdir: a path to the directory to write a minimized corpus.
                assume it as `os.path.join(self._workdir, f"{os.path.basename(corpus_dir)}_min)"` if it is not provided.
        Returns:
            a path to the directory where minimized corpus is written.
                None if minimizing process is failed.
        """
        raise NotImplementedError("Fuzzer.minimize is not implemented.")

    def batch_run(
        self,
        corpus_dirs: list[str],
        batch_size: int,
        fuzzdict: str | None = None,
        timeout: float | None = 300,
        runs: int | None = None,
        return_cov: bool = True,
    ) -> Iterator[tuple[str, int | Exception, tuple[Coverage, Coverage] | None]]:
        """Run the compiled harness in batch.
        Args:
            corpus_dirs: a list of corpus directories.
            batch_size: the desired concurrency level, maybe a size of the batch, or the number of the process.
            fuzzdict: a path to the fuzzing dictionary file.
            timeout: the maximum running time in seconds, None or indefinitely run.
            runs: the number of individual tests, None for indefinitely run.
            return_cov: whether return the coverage descriptors or not.
        Returns:
            str: a path to the corpus directory.
            int | Exception: the return code or the exceptions during run the fuzzer.
            tuple[Coverage, Coverage]: the coverage descriptors about library and fuzzer-itself.
        """
        for corpus_dir in corpus_dirs:
            try:
                retn = self.run(
                    corpus_dir,
                    fuzzdict,
                    wait_until_done=True,
                    timeout=timeout,
                    runs=runs,
                )
            except Exception as e:
                yield corpus_dir, e, None
            if not return_cov:
                yield corpus_dir, retn, None

            cov_lib = self.coverage()
            cov_fuzz = self.coverage(itself=True)
            yield corpus_dir, retn, (cov_lib, cov_fuzz)

    def run(
        self,
        corpus_dir: str | None = None,
        fuzzdict: str | None = None,
        wait_until_done: bool = False,
        timeout: float | None = 300,
        runs: int | None = None,
    ) -> int | Exception | None:
        """Run the compiled harness with given corpus directory and the fuzzer dictionary.
        Args:
            corpus_dir: a path to the directory containing fuzzing inputs (corpus).
            fuzzdict: a path to the fuzzing dictionary file.
            wait_until_done: wait for the fuzzer done if it is True.
            timeout: the maximum running time in seconds, None or indefinitely run.
            runs: the number of individual tests, None for indefinitely run.
        Returns:
            int: return code of the fuzzer process.
            None: if fuzzer process is now running.
            Exception: if the fuzzer process does not exist or timeout occured.
        """
        raise NotImplementedError("Fuzzer.run is not implemented.")

    def poll(self) -> int | Exception | None:
        """Poll the return code of the fuzzer process and clear if process done.
        Returns:
            int: return code of the fuzzer process.
            None: if fuzzer process is running now.
            Exception: if the fuzzer process deos not exist or timeout occured.
        """
        raise NotImplementedError("Fuzzer.poll is not implemented.")

    def halt(self) -> int | Exception:
        """Stop the fuzzer.
        Returnss:
            int: return code of the fuzzer proces.
            Exception: if the fuzzer process does not exist or timeout occured.
        """
        raise NotImplementedError("Fuzzer.halt is not implemented.")

    def track(self) -> int | float:
        """Monitor the coverage generated by the running fuzzer.
        Returns:
            the meausre of current coverage.
        """
        raise NotImplementedError("Fuzzer.track is not implemented.")

    def coverage(self, itself: bool = False) -> Coverage:
        """Collect the branch coverage of the last fuzzer run.
        Args:
            itself: whether compute the coverage of the harness itself or target library.
        Returns:
            computed branch coverage
        """
        raise NotImplementedError("Fuzzer.coverage is not implemented.")


class Compiler:
    """Compiler to make the harness executable."""

    def compile(self, srcfile: str) -> Fuzzer:
        """Compile the given harness to fuzzer object.
        Args:
            srcfile: a path to the source code file.
        Returns:
            fuzzer object.
        """
        raise NotImplementedError("Compiler.compile is not implemeneted.")
